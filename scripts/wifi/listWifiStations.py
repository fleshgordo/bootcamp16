#!/usr/local/bin/python3
# coding=utf8

import subprocess, glob, time, csv, random, argparse
import pprint
from collections import OrderedDict
from pythonosc import osc_message_builder
from pythonosc import udp_client

"""
 * CSV parsing and some sorting functions to
 * Gordan Savicic 22.9.2016
 * HEAD MA Media Design Geneva

 * airodump-ng is running and logging the results into a csv file
 * command: sudo airodump-ng -o csv -w test mon0
 * Make sure you run it from the same folder as the python script
 * subprocess looks for the last edited csv file in current folder
"""

# pretty print is neat
pp = pprint.PrettyPrinter(indent=4)

# Look for latest CSV file
csvs=subprocess.Popen("ls -t1 *csv | head -1", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
csv_last=csvs.communicate()[0].strip()

# define global dictionaries
wifiStations = {}
wifiClients = {}

""" Sort a nested dictionary
    Keyword arguments:
    _dict -- the dict to be sorted
    _sortByKey -- the key of the nested dict
"""
def sortDictByKey(_dict, _sortByKey):
    _dict = OrderedDict(sorted(_dict.items(), key=lambda x: x[1][_sortByKey]))
    return _dict

""" Reads a CSV file generated by airodump-ng and generates
    two dictionaries (stations/clients) with unique key based on the BSSID
    hardware MAC address

    Keyword arguments:
    dump -- filehandler to CSV file
"""
def lookup(dump):
    scan=open(dump, "rU",encoding='utf-8', errors='ignore')
    next(scan)

    scanDict=csv.DictReader((line.replace('\0','').replace(", ","\t") for line in scan), delimiter='\t')

    for aDict in scanDict:
        unwanted = [None, False]
        #print (aDict)
        #print (aDict)
        # other unwanted , 'Station MAC','Last time seen','BSSID','Probed ESSIDs','First time seen','# packets','Power'

        #aDictClean = {k.strip():v.strip() for k, v in aDict.items()  if v not in unwanted}
        aDictClean = aDict
        print(aDict)
        #aDictClean = aDict
        # check if we have stations or clients
        if "# IV" in aDictClean.keys():
            wifiStations[aDictClean["BSSID"]] = aDictClean
        else:
            if aDictClean["Privacy"] != "BSSID":
                wifiClients[aDictClean["BSSID"]] = aDictClean
            #continue
    pp.pprint(wifiStations)

""" MAIN loop
    do stuff here ....
"""
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    default_ip = "127.0.0.1"
    default_port = 6666
    parser.add_argument("--ip", default=default_ip,
    help="The ip of the OSC server")
    parser.add_argument("--port", type=int, default=default_port,
    help="The port the OSC server is listening on")
    args = parser.parse_args()

    c = udp_client.UDPClient(args.ip, args.port)
    ### Endless loop
    while True:
        lookup(csv_last)

        # sort by power or another possible value ESSID,  etc..
        # sortDictByKey(wifiStations,"Power")
        for k, v in wifiStations.items():
            oscmsg = []
            Oscmsg = osc_message_builder.OscMessageBuilder(address="/wifi")
            Oscmsg.add_arg("station")
            Oscmsg.add_arg(k)

            for nested_k, nested_v in v.items():
                Oscmsg.add_arg(str(nested_v))
            SendOSC = Oscmsg.build()
            c.send(SendOSC)

        time.sleep(4)
        # for k, v in wifiClients.iteritems():
        #     print "Clients: %s has Power: %s" %(wifiClients[k]["ESSID"], wifiClients[k]["Power"])
